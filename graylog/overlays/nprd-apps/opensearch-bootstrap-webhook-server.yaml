# OpenSearch Bootstrap Password Webhook Server
#
# Simple webhook server that mutates bootstrap pods to inject
# OPENSEARCH_INITIAL_ADMIN_PASSWORD environment variable.
#
# This deployment uses a simple Python Flask-based webhook server.
# For production, consider using a more robust webhook server implementation.
#
# The webhook server:
#   - Listens on port 8443 (HTTPS)
#   - Intercepts pod creation requests
#   - Identifies bootstrap pods (name ends with -bootstrap-0)
#   - Reads password from graylog-opensearch-admin-password secret
#   - Returns JSON patch to inject environment variable

apiVersion: v1
kind: ServiceAccount
metadata:
  name: opensearch-bootstrap-webhook
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: opensearch-bootstrap-webhook
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
rules:
  # Read the admin password secret
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["graylog-opensearch-admin-password"]
    verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: opensearch-bootstrap-webhook
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: opensearch-bootstrap-webhook
subjects:
  - kind: ServiceAccount
    name: opensearch-bootstrap-webhook
    namespace: managed-tools
---
apiVersion: v1
kind: Service
metadata:
  name: opensearch-bootstrap-webhook
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
spec:
  ports:
    - port: 443
      targetPort: 8443
      protocol: TCP
      name: webhook
  selector:
    app: opensearch-bootstrap-webhook
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opensearch-bootstrap-webhook
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opensearch-bootstrap-webhook
  template:
    metadata:
      labels:
        app: opensearch-bootstrap-webhook
    spec:
      serviceAccountName: opensearch-bootstrap-webhook
      containers:
        - name: webhook-server
          image: python:3.11-slim
          command:
            - /bin/sh
            - -c
            - |
              set -e
              pip install --no-cache-dir flask kubernetes
              python /app/webhook.py
          workingDir: /app
          volumeMounts:
            - name: webhook-script
              mountPath: /app/webhook.py
              subPath: webhook.py
            - name: cert
              mountPath: /certs
              readOnly: true
          ports:
            - containerPort: 8443
              name: webhook
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          resources:
            requests:
              cpu: 50m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /health
              port: 8443
              scheme: HTTPS
            initialDelaySeconds: 120
            periodSeconds: 30
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: 8443
              scheme: HTTPS
            initialDelaySeconds: 90
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
      volumes:
        - name: webhook-script
          configMap:
            name: opensearch-bootstrap-webhook-script
            defaultMode: 0755
        - name: cert
          secret:
            secretName: opensearch-bootstrap-webhook-cert
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opensearch-bootstrap-webhook-script
  namespace: managed-tools
  labels:
    app: opensearch-bootstrap-webhook
    managed-by: gitops
data:
  webhook.py: |
    #!/usr/bin/env python3
    """
    OpenSearch Bootstrap Password Webhook Server
    
    MutatingAdmissionWebhook that injects OPENSEARCH_INITIAL_ADMIN_PASSWORD
    into bootstrap pods when they are created.
    """
    import os
    import json
    import base64
    from flask import Flask, request, jsonify
    from kubernetes import client, config
    import ssl
    
    app = Flask(__name__)
    
    # Load in-cluster Kubernetes config
    try:
        config.load_incluster_config()
        v1 = client.CoreV1Api()
    except Exception as e:
        print(f"Error loading Kubernetes config: {e}")
        raise
    
    # Secret details
    SECRET_NAME = "graylog-opensearch-admin-password"
    SECRET_NAMESPACE = "managed-tools"
    SECRET_KEY = "password"
    ENV_VAR_NAME = "OPENSEARCH_INITIAL_ADMIN_PASSWORD"
    
    def get_password():
        """Read password from Kubernetes secret."""
        try:
            secret = v1.read_namespaced_secret(SECRET_NAME, SECRET_NAMESPACE)
            password = base64.b64decode(secret.data[SECRET_KEY]).decode('utf-8')
            return password
        except Exception as e:
            print(f"Error reading secret: {e}")
            raise
    
    @app.route('/health', methods=['GET'])
    def health():
        """Health check endpoint."""
        return jsonify({"status": "healthy"}), 200
    
    @app.route('/mutate', methods=['POST'])
    def mutate():
        """Mutate admission review request."""
        try:
            admission_review = request.json
            request_uid = admission_review.get('request', {}).get('uid')
            
            if not request_uid:
                return jsonify({
                    'apiVersion': 'admission.k8s.io/v1',
                    'kind': 'AdmissionReview',
                    'response': {
                        'allowed': False,
                        'status': {'message': 'Missing request UID'}
                    }
                }), 400
            
            pod = admission_review.get('request', {}).get('object', {})
            pod_metadata = pod.get('metadata', {})
            pod_name = pod_metadata.get('name', '')
            pod_namespace = pod_metadata.get('namespace', '')
            
            # Check if this is a bootstrap pod
            if not pod_name.endswith('-bootstrap-0'):
                # Not a bootstrap pod, allow without mutation
                return jsonify({
                    'apiVersion': 'admission.k8s.io/v1',
                    'kind': 'AdmissionReview',
                    'response': {
                        'uid': request_uid,
                        'allowed': True
                    }
                })
            
            # Check namespace
            if pod_namespace != SECRET_NAMESPACE:
                # Not in target namespace, allow without mutation
                return jsonify({
                    'apiVersion': 'admission.k8s.io/v1',
                    'kind': 'AdmissionReview',
                    'response': {
                        'uid': request_uid,
                        'allowed': True
                    }
                })
            
            # Check if password env already exists
            containers = pod.get('spec', {}).get('containers', [])
            if containers:
                env_vars = containers[0].get('env', [])
                for env_var in env_vars:
                    if env_var.get('name') == ENV_VAR_NAME:
                        # Already has password, allow without mutation
                        return jsonify({
                            'apiVersion': 'admission.k8s.io/v1',
                            'kind': 'AdmissionReview',
                            'response': {
                                'uid': request_uid,
                                'allowed': True
                            }
                        })
            
            # Get password from secret
            password = get_password()
            
            # Create JSON patch to inject environment variable
            patch = [
                {
                    'op': 'add',
                    'path': '/spec/containers/0/env/-',
                    'value': {
                        'name': ENV_VAR_NAME,
                        'value': password
                    }
                }
            ]
            
            # Return admission response with patch
            patch_str = json.dumps(patch)
            patch_base64 = base64.b64encode(patch_str.encode('utf-8')).decode('utf-8')
            
            return jsonify({
                'apiVersion': 'admission.k8s.io/v1',
                'kind': 'AdmissionReview',
                'response': {
                    'uid': request_uid,
                    'allowed': True,
                    'patchType': 'JSONPatch',
                    'patch': patch_base64
                }
            })
            
        except Exception as e:
            print(f"Error in mutate endpoint: {e}")
            import traceback
            traceback.print_exc()
            return jsonify({
                'apiVersion': 'admission.k8s.io/v1',
                'kind': 'AdmissionReview',
                'response': {
                    'uid': request_uid if 'request_uid' in locals() else '',
                    'allowed': False,
                    'status': {'message': str(e)}
                }
            }), 500
    
    if __name__ == '__main__':
        # Load TLS certificate
        cert_file = '/certs/tls.crt'
        key_file = '/certs/tls.key'
        
        if os.path.exists(cert_file) and os.path.exists(key_file):
            context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
            context.load_cert_chain(cert_file, key_file)
            app.run(host='0.0.0.0', port=8443, ssl_context=context, debug=False)
        else:
            print(f"WARNING: TLS certificate not found at {cert_file} and {key_file}")
            print("Running without TLS (NOT RECOMMENDED for production)")
            app.run(host='0.0.0.0', port=8443, debug=False)
