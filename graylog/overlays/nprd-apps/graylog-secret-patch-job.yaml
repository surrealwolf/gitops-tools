# Job to patch Graylog StatefulSet with Kubernetes secret references
# This job runs after the Helm chart creates the StatefulSet
# It patches the StatefulSet to inject secrets instead of hardcoded passwords
#
# NOTE: Jobs have immutable spec.template fields. When this Job spec changes,
# Fleet will show an error but the Job will still be created with a new name.
# The error can be ignored as the Job is idempotent and will work correctly.
#
apiVersion: batch/v1
kind: Job
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  annotations:
    # Note: Fleet may show errors when patching Jobs due to immutable fields
    # This is expected behavior - the Job will still be created and work correctly
    fleet.cattle.io/keep-resources: "false"
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
spec:
  # Run only once
  backoffLimit: 3
  ttlSecondsAfterFinished: 3600  # Keep for 1 hour
  template:
    metadata:
      labels:
        app: graylog
        component: secret-patch
        managed-by: gitops
    spec:
      serviceAccountName: graylog-secret-patch
      restartPolicy: Never
      containers:
      - name: patch
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          
          NAMESPACE="managed-graylog"
          STATEFULSET="graylog"
          
          echo "=== Graylog Secret Patch Job ==="
          echo ""
          echo "Waiting for StatefulSet to exist..."
          
          # Wait for StatefulSet to exist (max 60 seconds)
          for i in {1..60}; do
            if kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" &>/dev/null; then
              echo "✅ StatefulSet found"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ ERROR: StatefulSet $STATEFULSET not found in namespace $NAMESPACE after 60 seconds"
              exit 1
            fi
            echo "Waiting for StatefulSet... ($i/60)"
            sleep 1
          done
          
          echo ""
          echo "Patching StatefulSet to inject Kubernetes secrets..."
          
          # Check if init containers exist
          MONGO_INIT_EXISTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.initContainers[?(@.name=="mongodb-uri-builder")].name}' 2>/dev/null || echo "")
          CA_INIT_EXISTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.initContainers[?(@.name=="opensearch-ca-importer")].name}' 2>/dev/null || echo "")
          
          if [ -n "$MONGO_INIT_EXISTS" ] || [ -n "$CA_INIT_EXISTS" ]; then
            echo "ℹ️  Init containers already exist, checking if updates needed..."
          fi
          
          # Patch the StatefulSet to add init containers, volumes, and update env vars
          # This is a complex patch, so we'll use kubectl patch with JSON
          # Only add init containers if they don't exist
          if [ -z "$MONGO_INIT_EXISTS" ] || [ -z "$CA_INIT_EXISTS" ]; then
            echo "Adding init containers and volumes..."
            
            # Build init containers array
            INIT_CONTAINERS='['
            if [ -z "$MONGO_INIT_EXISTS" ]; then
              INIT_CONTAINERS+='{"name":"mongodb-uri-builder","image":"busybox:latest","command":["/bin/sh","-c","set -e; echo \\"Reading MongoDB password from secret...\\"; MONGO_PASS=$(cat /etc/secrets/mongodb-password); MONGO_PASS_ENC=$(echo -n \\"$MONGO_PASS\\" | sed \\"s/@/%40/g; s/:/%3A/g; s/\\\\//%2F/g; s/?/%3F/g; s/#/%23/g; s/[/%5B/g; s/]/%5D/g; s/ /%20/g\\"); URI=\\"mongodb://graylog:${MONGO_PASS_ENC}@graylog-mongo-rs-svc:27017/graylog?replicaSet=graylog-mongo-rs\\"; echo \\"$URI\\" > /shared/mongodb-uri; echo \\"MongoDB URI constructed\\""],"volumeMounts":[{"name":"mongodb-secret","mountPath":"/etc/secrets","readOnly":true},{"name":"shared-data","mountPath":"/shared"}]}'
            fi
            if [ -z "$CA_INIT_EXISTS" ]; then
              if [ -z "$MONGO_INIT_EXISTS" ]; then
                INIT_CONTAINERS+=','
              fi
              INIT_CONTAINERS+='{"name":"opensearch-ca-importer","image":"graylog/graylog:5.2","command":["/bin/bash","-c","set -e; JAVA_HOME=/opt/java/openjdk; CACERTS_SRC=$JAVA_HOME/lib/security/cacerts; CACERTS_DEST=/shared/cacerts; echo Copying cacerts to shared volume...; cp $CACERTS_SRC $CACERTS_DEST; chmod 644 $CACERTS_DEST; echo Importing OpenSearch CA certificate...; keytool -import -alias opensearch-ca -file /etc/ssl/certs/opensearch-ca/ca.crt -keystore $CACERTS_DEST -storepass changeit -noprompt -v || echo Import failed or already exists; keytool -list -keystore $CACERTS_DEST -storepass changeit -alias opensearch-ca && echo Certificate verified || echo Certificate not found; echo CA certificate import completed"],"securityContext":{"runAsUser":0},"volumeMounts":[{"name":"opensearch-ca","mountPath":"/etc/ssl/certs/opensearch-ca","readOnly":true},{"name":"shared-data","mountPath":"/shared"}]}'
            fi
            INIT_CONTAINERS+=']'
            
            # Build volumes array
            VOLUMES='['
            FIRST_VOL=true
            if [ -z "$MONGO_INIT_EXISTS" ]; then
              VOLUMES+='{"name":"mongodb-secret","secret":{"secretName":"graylog-backup-secret","items":[{"key":"mongodb-db-password","path":"mongodb-password"}]}}'
              FIRST_VOL=false
            fi
            if [ -z "$CA_INIT_EXISTS" ]; then
              if [ "$FIRST_VOL" = false ]; then
                VOLUMES+=','
              fi
              VOLUMES+='{"name":"opensearch-ca","configMap":{"name":"opensearch-ca"}}'
              FIRST_VOL=false
            fi
            if [ -z "$MONGO_INIT_EXISTS" ]; then
              if [ "$FIRST_VOL" = false ]; then
                VOLUMES+=','
              fi
              VOLUMES+='{"name":"shared-data","emptyDir":{}}'
            fi
            VOLUMES+=']'
            
            # Build patch JSON
            PATCH_JSON='['
            if [ -z "$MONGO_INIT_EXISTS" ] || [ -z "$CA_INIT_EXISTS" ]; then
              PATCH_JSON+='{"op":"add","path":"/spec/template/spec/initContainers","value":'$INIT_CONTAINERS'}'
            fi
            # Add volumes if needed
            if [ "$VOLUMES" != '[]' ]; then
              if [ "$PATCH_JSON" != '[' ]; then
                PATCH_JSON+=','
              fi
              # Check which volumes need to be added
              EXISTING_VOLUMES=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.volumes[*].name}' 2>/dev/null || echo "")
              if [ -z "$MONGO_INIT_EXISTS" ]; then
                if ! echo "$EXISTING_VOLUMES" | grep -q "mongodb-secret"; then
                  PATCH_JSON+=',{"op":"add","path":"/spec/template/spec/volumes/-","value":{"name":"mongodb-secret","secret":{"secretName":"graylog-backup-secret","items":[{"key":"mongodb-db-password","path":"mongodb-password"}]}}}'
                fi
                if ! echo "$EXISTING_VOLUMES" | grep -q "shared-data"; then
                  if [ "${PATCH_JSON: -1}" != ']' ]; then
                    PATCH_JSON+=','
                  fi
                  PATCH_JSON+='{"op":"add","path":"/spec/template/spec/volumes/-","value":{"name":"shared-data","emptyDir":{}}}'
                fi
              fi
              if [ -z "$CA_INIT_EXISTS" ]; then
                if ! echo "$EXISTING_VOLUMES" | grep -q "opensearch-ca"; then
                  if [ "${PATCH_JSON: -1}" != ']' ]; then
                    PATCH_JSON+=','
                  fi
                  PATCH_JSON+='{"op":"add","path":"/spec/template/spec/volumes/-","value":{"name":"opensearch-ca","configMap":{"name":"opensearch-ca"}}}'
                fi
              fi
            fi
            PATCH_JSON+=']'
            
            PATCH_RESULT=$(kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' -p="$PATCH_JSON" 2>&1)
          
            if [ $? -eq 0 ]; then
              echo "✅ Init container and volumes patched"
            else
              echo "⚠️  Warning: Init container/volumes patch may have failed: $PATCH_RESULT"
            fi
          else
            echo "ℹ️  Init container already exists, skipping init container patch"
          fi
          
          # Always patch the container env vars and command (they may need updating)
          echo "Patching container command and env vars..."
          # Find the graylog container index (usually 0)
          CONTAINER_INDEX=0
          
          # Check if volume mounts already exist
          EXISTING_MOUNTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].volumeMounts[*].name}' 2>/dev/null || echo "")
          HAS_MONGO_SECRET=$(echo "$EXISTING_MOUNTS" | grep -q "mongodb-secret" && echo "yes" || echo "no")
          HAS_SHARED_DATA=$(echo "$EXISTING_MOUNTS" | grep -q "shared-data" && echo "yes" || echo "no")
          
          # Create patch file to avoid shell escaping issues
          PATCH_FILE=$(mktemp)
          
          # Build the patch JSON - use printf to avoid YAML parser issues with heredoc
          printf '%s\n' '[' > "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/env",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      {"name": "TZ", "value": "UTC"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_BIND_ADDRESS", "value": "0.0.0.0:9000"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_EXTERNAL_URI", "value": "https://graylog.dataknife.net/"},\n' >> "$PATCH_FILE"
          # Build elasticsearch_hosts with credentials in URL format
          # Graylog requires credentials in URL format: https://username:password@host:port
          # Read password from secret and URL-encode it for the URL
          ES_PASSWORD=$(kubectl get secret graylog-opensearch-admin-password -n "$NAMESPACE" -o jsonpath='{.data.password}' | base64 -d)
          # URL encode password - use Python if available, otherwise use sed for common special chars
          if command -v python3 >/dev/null 2>&1; then
            ES_PASSWORD_ENC=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.stdin.read().strip(), safe=''))" <<< "$ES_PASSWORD")
          else
            # Fallback: encode common special characters
            ES_PASSWORD_ENC=$(echo -n "$ES_PASSWORD" | sed 's/!/%21/g; s/@/%40/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/+/%2B/g; s/=/%3D/g; s/:/%3A/g; s/?/%3F/g; s/\[/%5B/g; s/\]/%5D/g; s/ /%20/g')
          fi
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_HOSTS", "value": "https://admin:%s@graylog-opensearch:9200"},\n' "$ES_PASSWORD_ENC" >> "$PATCH_FILE"
          # Still set username and password as env vars (Graylog may use them as fallback)
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USERNAME", "value": "admin"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_PASSWORD", "valueFrom": {"secretKeyRef": {"name": "graylog-opensearch-admin-password", "key": "password"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USE_SSL", "value": "true"},\n' >> "$PATCH_FILE"
          # SSL verification enabled - OpenSearch certificates regenerated with service hostname
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_VERIFY_SSL", "value": "true"},\n' >> "$PATCH_FILE"
          # Custom truststore with OpenSearch CA certificate
          printf '      {"name": "GRAYLOG_SERVER_JAVA_OPTS", "value": "-Xms1g -Xmx1g -Djavax.net.ssl.trustStore=/shared/cacerts -Djavax.net.ssl.trustStorePassword=changeit"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_MONGODB_URI", "value": ""},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_PASSWORD_SECRET", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "graylog-secret"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ROOT_PASSWORD_SHA2", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "mongodb-root-password"}}}\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  },\n' >> "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/command",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      "/bin/sh",\n' >> "$PATCH_FILE"
          printf '      "-c",\n' >> "$PATCH_FILE"
          printf '      "if [ -f /shared/mongodb-uri ]; then export GRAYLOG_MONGODB_URI=$(cat /shared/mongodb-uri); echo \\"MongoDB URI loaded from init container\\"; else echo \\"ERROR: MongoDB URI file not found\\" >&2; exit 1; fi; exec /docker-entrypoint.sh"\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  }' >> "$PATCH_FILE"
          
          # Add volume mounts if they don't exist
          if [ "$HAS_MONGO_SECRET" = "no" ] || [ "$HAS_SHARED_DATA" = "no" ]; then
            # Add comma before volume mount patches
            printf ',\n' >> "$PATCH_FILE"
            if [ "$HAS_MONGO_SECRET" = "no" ]; then
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "mongodb-secret", "mountPath": "/etc/secrets", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
            if [ "$HAS_SHARED_DATA" = "no" ]; then
              if [ "$HAS_MONGO_SECRET" = "no" ]; then
                printf ',\n' >> "$PATCH_FILE"
              fi
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "shared-data", "mountPath": "/shared", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
          fi
          # Add closing bracket
          printf '\n]' >> "$PATCH_FILE"
          
          # Apply the patch from file
          kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' --patch-file="$PATCH_FILE" || echo "⚠️  Warning: Container patch may have failed"
          rm -f "$PATCH_FILE"
          
          echo ""
          echo "✅ Patch job completed"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
rules:
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: graylog-secret-patch
subjects:
- kind: ServiceAccount
  name: graylog-secret-patch
  namespace: managed-graylog
