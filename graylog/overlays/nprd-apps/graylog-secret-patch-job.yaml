# Job to patch Graylog StatefulSet with Kubernetes secret references
# This job runs after the Helm chart creates the StatefulSet
# It patches the StatefulSet to inject secrets instead of hardcoded passwords
#
# NOTE: Jobs have immutable spec.template fields. When this Job spec changes,
# Fleet will show an error but the Job will still be created with a new name.
# The error can be ignored as the Job is idempotent and will work correctly.
#
apiVersion: batch/v1
kind: Job
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  annotations:
    # Note: Fleet may show errors when patching Jobs due to immutable fields
    # This is expected behavior - the Job will still be created and work correctly
    fleet.cattle.io/keep-resources: "false"
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
spec:
  # Run only once
  backoffLimit: 3
  ttlSecondsAfterFinished: 3600  # Keep for 1 hour
  template:
    metadata:
      labels:
        app: graylog
        component: secret-patch
        managed-by: gitops
    spec:
      serviceAccountName: graylog-secret-patch
      restartPolicy: Never
      containers:
      - name: patch
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          
          NAMESPACE="managed-graylog"
          STATEFULSET="graylog"
          
          echo "=== Graylog Secret Patch Job ==="
          echo ""
          echo "Waiting for StatefulSet to exist..."
          
          # Wait for StatefulSet to exist (max 60 seconds)
          for i in {1..60}; do
            if kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" &>/dev/null; then
              echo "✅ StatefulSet found"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ ERROR: StatefulSet $STATEFULSET not found in namespace $NAMESPACE after 60 seconds"
              exit 1
            fi
            echo "Waiting for StatefulSet... ($i/60)"
            sleep 1
          done
          
          echo ""
          echo "Patching StatefulSet to inject Kubernetes secrets..."
          
          # Check if init container exists (but continue to patch command if needed)
          INIT_EXISTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.initContainers[?(@.name=="mongodb-uri-builder")].name}' 2>/dev/null || echo "")
          if [ -n "$INIT_EXISTS" ]; then
            echo "ℹ️  Init container already exists, checking if command needs patching..."
          fi
          
          # Patch the StatefulSet to add init container, volumes, and update env vars
          # This is a complex patch, so we'll use kubectl patch with JSON
          # Only add init container if it doesn't exist
          if [ -z "$INIT_EXISTS" ]; then
            echo "Adding init container and volumes..."
            PATCH_RESULT=$(kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' -p='
          [
            {
              "op": "add",
              "path": "/spec/template/spec/initContainers",
              "value": [
                {
                  "name": "mongodb-uri-builder",
                  "image": "busybox:latest",
                  "command": ["/bin/sh", "-c", "set -e; echo \"Reading MongoDB password from secret...\"; MONGO_PASS=$(cat /etc/secrets/mongodb-password); MONGO_PASS_ENC=$(echo -n \"$MONGO_PASS\" | sed \"s/@/%40/g; s/:/%3A/g; s/\\//%2F/g; s/?/%3F/g; s/#/%23/g; s/[/%5B/g; s/]/%5D/g; s/ /%20/g\"); URI=\"mongodb://graylog:${MONGO_PASS_ENC}@graylog-mongo-rs-svc:27017/graylog?replicaSet=graylog-mongo-rs\"; echo \"$URI\" > /shared/mongodb-uri; echo \"MongoDB URI constructed\""],
                  "volumeMounts": [
                    {"name": "mongodb-secret", "mountPath": "/etc/secrets", "readOnly": true},
                    {"name": "shared-data", "mountPath": "/shared"}
                  ]
                }
              ]
            },
            {
              "op": "add",
              "path": "/spec/template/spec/volumes/-",
              "value": {
                "name": "mongodb-secret",
                "secret": {
                  "secretName": "graylog-backup-secret",
                  "items": [{"key": "mongodb-db-password", "path": "mongodb-password"}]
                }
              }
            },
            {
              "op": "add",
              "path": "/spec/template/spec/volumes/-",
              "value": {
                "name": "shared-data",
                "emptyDir": {}
              }
            }
          ]' 2>&1)
          
            if [ $? -eq 0 ]; then
              echo "✅ Init container and volumes patched"
            else
              echo "⚠️  Warning: Init container/volumes patch may have failed: $PATCH_RESULT"
            fi
          else
            echo "ℹ️  Init container already exists, skipping init container patch"
          fi
          
          # Always patch the container env vars and command (they may need updating)
          echo "Patching container command and env vars..."
          # Find the graylog container index (usually 0)
          CONTAINER_INDEX=0
          
          # Check if volume mounts already exist
          EXISTING_MOUNTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].volumeMounts[*].name}' 2>/dev/null || echo "")
          HAS_MONGO_SECRET=$(echo "$EXISTING_MOUNTS" | grep -q "mongodb-secret" && echo "yes" || echo "no")
          HAS_SHARED_DATA=$(echo "$EXISTING_MOUNTS" | grep -q "shared-data" && echo "yes" || echo "no")
          
          # Create patch file to avoid shell escaping issues
          PATCH_FILE=$(mktemp)
          
          # Build the patch JSON - use printf to avoid YAML parser issues with heredoc
          printf '%s\n' '[' > "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/env",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      {"name": "TZ", "value": "UTC"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_BIND_ADDRESS", "value": "0.0.0.0:9000"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_EXTERNAL_URI", "value": "https://graylog.dataknife.net/"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_HOSTS", "value": "https://graylog-opensearch:9200"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USERNAME", "value": "admin"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_PASSWORD", "valueFrom": {"secretKeyRef": {"name": "graylog-opensearch-admin-password", "key": "password"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USE_SSL", "value": "true"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_VERIFY_SSL", "value": "false"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_MONGODB_URI", "value": ""},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_PASSWORD_SECRET", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "graylog-secret"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ROOT_PASSWORD_SHA2", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "mongodb-root-password"}}}\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  },\n' >> "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/command",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      "/bin/sh",\n' >> "$PATCH_FILE"
          printf '      "-c",\n' >> "$PATCH_FILE"
          printf '      "if [ -f /shared/mongodb-uri ]; then export GRAYLOG_MONGODB_URI=$(cat /shared/mongodb-uri); echo \\"MongoDB URI loaded from init container\\"; else echo \\"ERROR: MongoDB URI file not found\\" >&2; exit 1; fi; exec /docker-entrypoint.sh"\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  }' >> "$PATCH_FILE"
          
          # Add volume mounts if they don't exist
          if [ "$HAS_MONGO_SECRET" = "no" ] || [ "$HAS_SHARED_DATA" = "no" ]; then
            # Add comma before volume mount patches
            printf ',\n' >> "$PATCH_FILE"
            if [ "$HAS_MONGO_SECRET" = "no" ]; then
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "mongodb-secret", "mountPath": "/etc/secrets", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
            if [ "$HAS_SHARED_DATA" = "no" ]; then
              if [ "$HAS_MONGO_SECRET" = "no" ]; then
                printf ',\n' >> "$PATCH_FILE"
              fi
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "shared-data", "mountPath": "/shared", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
          fi
          # Add closing bracket
          printf '\n]' >> "$PATCH_FILE"
          
          # Apply the patch from file
          kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' --patch-file="$PATCH_FILE" || echo "⚠️  Warning: Container patch may have failed"
          rm -f "$PATCH_FILE"
          
          echo ""
          echo "✅ Patch job completed"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
rules:
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: graylog-secret-patch
subjects:
- kind: ServiceAccount
  name: graylog-secret-patch
  namespace: managed-graylog
