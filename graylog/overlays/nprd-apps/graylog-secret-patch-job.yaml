# Job to patch Graylog StatefulSet with Kubernetes secret references
# This job runs after the Helm chart creates the StatefulSet
# It patches the StatefulSet to inject secrets instead of hardcoded passwords
#
# NOTE: Jobs have immutable spec.template fields. When this Job spec changes,
# Fleet will show an error but the Job will still be created with a new name.
# The error can be ignored as the Job is idempotent and will work correctly.
#
apiVersion: batch/v1
kind: Job
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  annotations:
    # Note: Fleet may show errors when patching Jobs due to immutable fields
    # This is expected behavior - the Job will still be created and work correctly
    fleet.cattle.io/keep-resources: "false"
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
spec:
  # Run only once
  backoffLimit: 3
  ttlSecondsAfterFinished: 3600  # Keep for 1 hour
  template:
    metadata:
      labels:
        app: graylog
        component: secret-patch
        managed-by: gitops
    spec:
      serviceAccountName: graylog-secret-patch
      restartPolicy: Never
      containers:
      - name: patch
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -o pipefail  # Exit on pipe failures, but allow command failures to be checked
          
          NAMESPACE="managed-graylog"
          STATEFULSET="graylog"
          
          echo "=== Graylog Secret Patch Job ==="
          echo ""
          echo "Waiting for StatefulSet to exist..."
          
          # Wait for StatefulSet to exist (max 60 seconds)
          for i in {1..60}; do
            if kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" &>/dev/null; then
              echo "✅ StatefulSet found"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ ERROR: StatefulSet $STATEFULSET not found in namespace $NAMESPACE after 60 seconds"
              exit 1
            fi
            echo "Waiting for StatefulSet... ($i/60)"
            sleep 1
          done
          
          echo ""
          echo "Patching StatefulSet to inject Kubernetes secrets..."
          
          # Check if init containers exist
          MONGO_INIT_EXISTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.initContainers[?(@.name=="mongodb-uri-builder")].name}' 2>/dev/null || echo "")
          CA_INIT_EXISTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.initContainers[?(@.name=="opensearch-ca-importer")].name}' 2>/dev/null || echo "")
          
          if [ -n "$MONGO_INIT_EXISTS" ] || [ -n "$CA_INIT_EXISTS" ]; then
            echo "ℹ️  Init containers already exist, checking if updates needed..."
          fi
          
          # Patch the StatefulSet to add init containers, volumes, and update env vars
          # This is a complex patch, so we'll use kubectl patch with JSON
          # Only add init containers if they don't exist
          if [ -z "$MONGO_INIT_EXISTS" ] || [ -z "$CA_INIT_EXISTS" ]; then
            echo "Adding init containers and volumes..."
            
            # Create patch file to avoid shell escaping issues
            INIT_PATCH_FILE=$(mktemp)
            
            # Check which volumes need to be added
            EXISTING_VOLUMES=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.volumes[*].name}' 2>/dev/null || echo "")
            
            # Build patch JSON using printf to file (avoids escaping issues)
            printf '%s\n' '[' > "$INIT_PATCH_FILE"
            FIRST_OP=true
            
            # Add init containers using array append (-)
            if [ -z "$MONGO_INIT_EXISTS" ]; then
              if [ "$FIRST_OP" = false ]; then
                printf ',\n' >> "$INIT_PATCH_FILE"
              fi
              printf '  {\n' >> "$INIT_PATCH_FILE"
              printf '    "op": "add",\n' >> "$INIT_PATCH_FILE"
              printf '    "path": "/spec/template/spec/initContainers/-",\n' >> "$INIT_PATCH_FILE"
              printf '    "value": {\n' >> "$INIT_PATCH_FILE"
              printf '      "name": "mongodb-uri-builder",\n' >> "$INIT_PATCH_FILE"
              printf '      "image": "busybox:latest",\n' >> "$INIT_PATCH_FILE"
              printf '%s\n' '      "command": ["/bin/sh", "-c", "set -e; echo \"Reading MongoDB password from secret...\"; MONGO_PASS=$(cat /etc/secrets/mongodb-password); MONGO_PASS_ENC=$(echo -n \"$MONGO_PASS\" | sed \"s/@/%%40/g; s/:/%%3A/g; s/\\//%%2F/g; s/?/%%3F/g; s/#/%%23/g; s/[/%%5B/g; s/]/%%5D/g; s/ /%%20/g\"); URI=\"mongodb://graylog:${MONGO_PASS_ENC}@graylog-mongo-rs-svc:27017/graylog?replicaSet=graylog-mongo-rs\"; echo \"$URI\" > /shared/mongodb-uri; echo \"MongoDB URI constructed\""],' >> "$INIT_PATCH_FILE"
              printf '      "volumeMounts": [{"name": "mongodb-secret", "mountPath": "/etc/secrets", "readOnly": true}, {"name": "shared-data", "mountPath": "/shared"}]\n' >> "$INIT_PATCH_FILE"
              printf '    }\n' >> "$INIT_PATCH_FILE"
              printf '  }' >> "$INIT_PATCH_FILE"
              FIRST_OP=false
            fi
            
            if [ -z "$CA_INIT_EXISTS" ]; then
              if [ "$FIRST_OP" = false ]; then
                printf ',\n' >> "$INIT_PATCH_FILE"
              fi
              printf '  {\n' >> "$INIT_PATCH_FILE"
              printf '    "op": "add",\n' >> "$INIT_PATCH_FILE"
              printf '    "path": "/spec/template/spec/initContainers/-",\n' >> "$INIT_PATCH_FILE"
              printf '    "value": {\n' >> "$INIT_PATCH_FILE"
              printf '      "name": "opensearch-ca-importer",\n' >> "$INIT_PATCH_FILE"
              printf '      "image": "graylog/graylog:7.0",\n' >> "$INIT_PATCH_FILE"
              printf '      "command": ["/bin/bash", "-c", "set -e; JAVA_HOME=/opt/java/openjdk; CACERTS_SRC=$JAVA_HOME/lib/security/cacerts; CACERTS_DEST=/shared/cacerts; echo Copying cacerts to shared volume...; cp $CACERTS_SRC $CACERTS_DEST; chmod 644 $CACERTS_DEST; echo Importing OpenSearch CA certificate...; keytool -import -alias opensearch-ca -file /etc/ssl/certs/opensearch-ca/ca.crt -keystore $CACERTS_DEST -storepass changeit -noprompt -v || echo Import failed or already exists; keytool -list -keystore $CACERTS_DEST -storepass changeit -alias opensearch-ca && echo Certificate verified || echo Certificate not found; echo CA certificate import completed"],\n' >> "$INIT_PATCH_FILE"
              printf '      "securityContext": {"runAsUser": 0},\n' >> "$INIT_PATCH_FILE"
              printf '      "volumeMounts": [{"name": "opensearch-ca", "mountPath": "/etc/ssl/certs/opensearch-ca", "readOnly": true}, {"name": "shared-data", "mountPath": "/shared"}]\n' >> "$INIT_PATCH_FILE"
              printf '    }\n' >> "$INIT_PATCH_FILE"
              printf '  }' >> "$INIT_PATCH_FILE"
              FIRST_OP=false
            fi
            
            # Add volumes if needed
            if [ -z "$MONGO_INIT_EXISTS" ]; then
              if ! echo "$EXISTING_VOLUMES" | grep -q "mongodb-secret"; then
                if [ "$FIRST_OP" = false ]; then
                  printf ',\n' >> "$INIT_PATCH_FILE"
                fi
                printf '  {\n' >> "$INIT_PATCH_FILE"
                printf '    "op": "add",\n' >> "$INIT_PATCH_FILE"
                printf '    "path": "/spec/template/spec/volumes/-",\n' >> "$INIT_PATCH_FILE"
                printf '    "value": {\n' >> "$INIT_PATCH_FILE"
                printf '      "name": "mongodb-secret",\n' >> "$INIT_PATCH_FILE"
                printf '      "secret": {\n' >> "$INIT_PATCH_FILE"
                printf '        "secretName": "graylog-backup-secret",\n' >> "$INIT_PATCH_FILE"
                printf '        "items": [{"key": "mongodb-db-password", "path": "mongodb-password"}]\n' >> "$INIT_PATCH_FILE"
                printf '      }\n' >> "$INIT_PATCH_FILE"
                printf '    }\n' >> "$INIT_PATCH_FILE"
                printf '  }' >> "$INIT_PATCH_FILE"
                FIRST_OP=false
              fi
              if ! echo "$EXISTING_VOLUMES" | grep -q "shared-data"; then
                if [ "$FIRST_OP" = false ]; then
                  printf ',\n' >> "$INIT_PATCH_FILE"
                fi
                printf '  {\n' >> "$INIT_PATCH_FILE"
                printf '    "op": "add",\n' >> "$INIT_PATCH_FILE"
                printf '    "path": "/spec/template/spec/volumes/-",\n' >> "$INIT_PATCH_FILE"
                printf '    "value": {"name": "shared-data", "emptyDir": {}}\n' >> "$INIT_PATCH_FILE"
                printf '  }' >> "$INIT_PATCH_FILE"
                FIRST_OP=false
              fi
            fi
            
            if [ -z "$CA_INIT_EXISTS" ]; then
              if ! echo "$EXISTING_VOLUMES" | grep -q "opensearch-ca"; then
                if [ "$FIRST_OP" = false ]; then
                  printf ',\n' >> "$INIT_PATCH_FILE"
                fi
                printf '  {\n' >> "$INIT_PATCH_FILE"
                printf '    "op": "add",\n' >> "$INIT_PATCH_FILE"
                printf '    "path": "/spec/template/spec/volumes/-",\n' >> "$INIT_PATCH_FILE"
                printf '    "value": {"name": "opensearch-ca", "configMap": {"name": "opensearch-ca"}}\n' >> "$INIT_PATCH_FILE"
                printf '  }' >> "$INIT_PATCH_FILE"
                FIRST_OP=false
              fi
            fi
            
            printf '\n]' >> "$INIT_PATCH_FILE"
            
            # Apply the patch from file
            PATCH_RESULT=$(kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' --patch-file="$INIT_PATCH_FILE" 2>&1)
            PATCH_EXIT=$?
            rm -f "$INIT_PATCH_FILE"
            
            if [ $PATCH_EXIT -eq 0 ]; then
              echo "✅ Init container and volumes patched"
            else
              echo "❌ ERROR: Init container/volumes patch failed: $PATCH_RESULT"
              echo "Continuing with env/command patch..."
            fi
          else
            echo "ℹ️  Init container already exists, skipping init container patch"
          fi
          
          # Always patch the container env vars and command (they may need updating)
          echo "Patching container command and env vars..."
          # Find the graylog container index (usually 0)
          CONTAINER_INDEX=0
          
          # Check if volume mounts already exist
          EXISTING_MOUNTS=$(kubectl get statefulset "$STATEFULSET" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].volumeMounts[*].name}' 2>/dev/null || echo "")
          HAS_MONGO_SECRET=$(echo "$EXISTING_MOUNTS" | grep -q "mongodb-secret" && echo "yes" || echo "no")
          HAS_SHARED_DATA=$(echo "$EXISTING_MOUNTS" | grep -q "shared-data" && echo "yes" || echo "no")
          
          # Create patch file to avoid shell escaping issues
          PATCH_FILE=$(mktemp)
          
          # Build the patch JSON - use printf to avoid YAML parser issues with heredoc
          printf '%s\n' '[' > "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/env",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      {"name": "TZ", "value": "UTC"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_BIND_ADDRESS", "value": "0.0.0.0:9000"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_HTTP_EXTERNAL_URI", "value": "https://graylog.dataknife.net/"},\n' >> "$PATCH_FILE"
          # Build elasticsearch_hosts with credentials in URL format
          # Graylog requires credentials in URL format: https://username:password@host:port
          # Read password from secret and URL-encode it for the URL
          ES_PASSWORD=$(kubectl get secret graylog-opensearch-admin-password -n "$NAMESPACE" -o jsonpath='{.data.password}' | base64 -d)
          # URL encode password - use Python if available, otherwise use sed for common special chars
          if command -v python3 >/dev/null 2>&1; then
            ES_PASSWORD_ENC=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.stdin.read().strip(), safe=''))" <<< "$ES_PASSWORD")
          else
            # Fallback: encode common special characters
            ES_PASSWORD_ENC=$(echo -n "$ES_PASSWORD" | sed 's/!/%21/g; s/@/%40/g; s/#/%23/g; s/\$/%24/g; s/&/%26/g; s/+/%2B/g; s/=/%3D/g; s/:/%3A/g; s/?/%3F/g; s/\[/%5B/g; s/\]/%5D/g; s/ /%20/g')
          fi
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_HOSTS", "value": "https://admin:%s@graylog-opensearch:9200"},\n' "$ES_PASSWORD_ENC" >> "$PATCH_FILE"
          # Still set username and password as env vars (Graylog may use them as fallback)
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USERNAME", "value": "admin"},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_PASSWORD", "valueFrom": {"secretKeyRef": {"name": "graylog-opensearch-admin-password", "key": "password"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_USE_SSL", "value": "true"},\n' >> "$PATCH_FILE"
          # SSL verification enabled - OpenSearch certificates regenerated with service hostname
          printf '      {"name": "GRAYLOG_ELASTICSEARCH_VERIFY_SSL", "value": "true"},\n' >> "$PATCH_FILE"
          # Custom truststore with OpenSearch CA certificate
          printf '      {"name": "GRAYLOG_SERVER_JAVA_OPTS", "value": "-Xms1g -Xmx1g -Djavax.net.ssl.trustStore=/shared/cacerts -Djavax.net.ssl.trustStorePassword=changeit"},\n' >> "$PATCH_FILE"
          # GRAYLOG_MONGODB_URI will be set by the command from /shared/mongodb-uri file created by init container
          # Don't set it here as empty string causes validation error - let command set it
          printf '      {"name": "GRAYLOG_PASSWORD_SECRET", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "graylog-secret"}}},\n' >> "$PATCH_FILE"
          printf '      {"name": "GRAYLOG_ROOT_PASSWORD_SHA2", "valueFrom": {"secretKeyRef": {"name": "graylog-backup-secret", "key": "mongodb-root-password"}}}\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  },\n' >> "$PATCH_FILE"
          printf '  {\n' >> "$PATCH_FILE"
          printf '    "op": "replace",\n' >> "$PATCH_FILE"
          printf '    "path": "/spec/template/spec/containers/0/command",\n' >> "$PATCH_FILE"
          printf '    "value": [\n' >> "$PATCH_FILE"
          printf '      "/bin/sh",\n' >> "$PATCH_FILE"
          printf '      "-c",\n' >> "$PATCH_FILE"
          printf '      "if [ -f /shared/mongodb-uri ]; then export GRAYLOG_MONGODB_URI=$(cat /shared/mongodb-uri); echo \\"MongoDB URI loaded from init container\\"; else echo \\"ERROR: MongoDB URI file not found\\" >&2; exit 1; fi; exec /docker-entrypoint.sh"\n' >> "$PATCH_FILE"
          printf '    ]\n' >> "$PATCH_FILE"
          printf '  }' >> "$PATCH_FILE"
          
          # Add volume mounts if they don't exist
          if [ "$HAS_MONGO_SECRET" = "no" ] || [ "$HAS_SHARED_DATA" = "no" ]; then
            # Add comma before volume mount patches
            printf ',\n' >> "$PATCH_FILE"
            if [ "$HAS_MONGO_SECRET" = "no" ]; then
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "mongodb-secret", "mountPath": "/etc/secrets", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
            if [ "$HAS_SHARED_DATA" = "no" ]; then
              if [ "$HAS_MONGO_SECRET" = "no" ]; then
                printf ',\n' >> "$PATCH_FILE"
              fi
              printf '  {\n' >> "$PATCH_FILE"
              printf '    "op": "add",\n' >> "$PATCH_FILE"
              printf '    "path": "/spec/template/spec/containers/0/volumeMounts/-",\n' >> "$PATCH_FILE"
              printf '    "value": {"name": "shared-data", "mountPath": "/shared", "readOnly": true}\n' >> "$PATCH_FILE"
              printf '  }' >> "$PATCH_FILE"
            fi
          fi
          # Add closing bracket
          printf '\n]' >> "$PATCH_FILE"
          
          # Apply the patch from file
          PATCH_RESULT=$(kubectl patch statefulset "$STATEFULSET" -n "$NAMESPACE" --type='json' --patch-file="$PATCH_FILE" 2>&1)
          PATCH_EXIT=$?
          rm -f "$PATCH_FILE"
          
          if [ $PATCH_EXIT -eq 0 ]; then
            echo ""
            echo "✅ Container env/command patch completed"
          else
            echo ""
            echo "❌ ERROR: Container patch failed: $PATCH_RESULT"
            exit 1
          fi
          
          echo ""
          echo "✅ Patch job completed successfully"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
rules:
- apiGroups: ["apps"]
  resources: ["statefulsets"]
  verbs: ["get", "patch"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]
  resourceNames: ["graylog-opensearch-admin-password"]  # Only allow reading this specific secret
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: graylog-secret-patch
  namespace: managed-graylog
  labels:
    app: graylog
    component: secret-patch
    managed-by: gitops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: graylog-secret-patch
subjects:
- kind: ServiceAccount
  name: graylog-secret-patch
  namespace: managed-graylog
