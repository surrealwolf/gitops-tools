# Wazuh Server StatefulSet
# Based on official Wazuh Kubernetes manifests
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: wazuh-server
  namespace: managed-tools
  labels:
    app: wazuh
    component: server
    managed-by: gitops
spec:
  serviceName: wazuh-server
  replicas: 1
  selector:
    matchLabels:
      app: wazuh
      component: server
  template:
    metadata:
      labels:
        app: wazuh
        component: server
        managed-by: gitops
    spec:
      volumes:
        - name: filebeat-config
          configMap:
            name: wazuh-server-filebeat-config
        - name: indexer-certs
          secret:
            secretName: wazuh-certs
            defaultMode: 0600
        - name: syslog-config
          configMap:
            name: wazuh-server-syslog-config
            defaultMode: 0755
        - name: unifi-decoder-config
          configMap:
            name: wazuh-unifi-decoder-config
            defaultMode: 0755
        - name: ossec-etc
          emptyDir: {}
          # EmptyDir volume for /var/ossec/etc (initContainer copies default files here and modifies them)
      initContainers:
        # InitContainer 1: Copy default config files and inject syslog configuration
        - name: configure-ossec
          image: wazuh/wazuh-manager:4.14.1
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -e
              echo "=== Step 1: Copying default /var/ossec/etc files to emptyDir ==="
              # Ensure target directory exists
              mkdir -p /tmp/ossec-etc
              # Copy entire /var/ossec/etc directory structure (default from image)
              if [ -d "/var/ossec/etc" ]; then
                cp -a /var/ossec/etc/* /tmp/ossec-etc/ 2>/dev/null || true
                # Copy hidden files (but not . and ..)
                for file in /var/ossec/etc/.[^.]*; do
                  [ -e "$file" ] && cp -a "$file" /tmp/ossec-etc/ 2>/dev/null || true
                done
                echo "✅ Copied default /var/ossec/etc files"
              else
                echo "⚠️  /var/ossec/etc not found, using empty structure"
              fi
              
              # Ensure custom directories exist
              mkdir -p /tmp/ossec-etc/decoders/custom
              mkdir -p /tmp/ossec-etc/rules/custom
              echo "✅ Created custom decoder and rules directories"
              
              echo "=== Step 2: Injecting syslog remote configuration ==="
              # Use Python to inject syslog remote block into ossec.conf
              # Note: Wazuh allows multiple <ossec_config> blocks, but we'll insert into the first one
              python3 << 'PYTHON_SCRIPT'
              import sys
              import re
              
              ossec_conf = "/tmp/ossec-etc/ossec.conf"
              syslog_fragment = "/tmp/syslog-config/syslog-remote.xml"
              
              # Read the default ossec.conf
              with open(ossec_conf, 'r') as f:
                  content = f.read()
              
              # Check if syslog remote already exists - if so, remove it first (we'll re-add with updated config)
              if '<connection>syslog</connection>' in content:
                  print("⚠️  Syslog remote configuration already exists, updating...")
                  # Remove existing syslog remote block using line-by-line approach
                  # This is more reliable than regex for handling comments and multi-line blocks
                  import re
                  lines = content.split('\n')
                  new_lines = []
                  skip_until_close = False
                  in_syslog_block = False
                  comment_context = []
                  
                  for i, line in enumerate(lines):
                      # Check if we're entering a syslog remote block
                      if '<connection>syslog</connection>' in line:
                          in_syslog_block = True
                          # Don't add this line - we're removing the whole block
                          # Capture preceding comment lines if any
                          # Look backwards for comment lines related to syslog
                          j = i - 1
                          while j >= 0 and (lines[j].strip().startswith('<!--') or not lines[j].strip()):
                              if 'syslog' in lines[j].lower():
                                  comment_context.insert(0, j)
                              j -= 1
                          continue
                      
                      # If we're in a syslog block, skip lines until we find closing </remote>
                      if in_syslog_block:
                          if '</remote>' in line:
                              in_syslog_block = False
                              skip_until_close = False
                              # Also remove any comment lines we captured
                              for comment_idx in reversed(comment_context):
                                  # Remove comment line if it's still in new_lines
                                  if comment_idx < len(new_lines):
                                      if comment_idx < len(new_lines) and 'syslog' in new_lines[comment_idx].lower():
                                          new_lines.pop(comment_idx)
                              comment_context = []
                              continue
                          else:
                              # Still in block, skip this line
                              continue
                      
                      # Not in syslog block, keep the line
                      new_lines.append(line)
                  
                  content = '\n'.join(new_lines)
                  # Clean up extra blank lines
                  content = re.sub(r'\n{3,}', '\n\n', content)
                  print("✅ Removed existing syslog remote block (including preceding comments), will add updated version")
              
              # Read syslog fragment
              with open(syslog_fragment, 'r') as f:
                  syslog_xml = f.read().strip()
              
              # Find the LAST closing </ossec_config> tag (in case there are multiple blocks)
              # and insert before it. Preserve indentation.
              lines = content.split('\n')
              
              # Find the last </ossec_config> tag
              last_ossec_config_idx = -1
              indent = "  "
              for i in range(len(lines) - 1, -1, -1):
                  if '</ossec_config>' in lines[i]:
                      last_ossec_config_idx = i
                      # Extract indentation
                      match = re.match(r'^(\s+)</ossec_config>', lines[i])
                      if match:
                          indent = match.group(1)
                      break
              
              if last_ossec_config_idx == -1:
                  print("❌ ERROR: Could not find </ossec_config> closing tag")
                  sys.exit(1)
              
              # Indent the syslog fragment to match
              indented_syslog_lines = [indent + line if line.strip() else line 
                                       for line in syslog_xml.split('\n')]
              indented_syslog = '\n' + '\n'.join(indented_syslog_lines)
              
              # Insert before the last </ossec_config>
              lines.insert(last_ossec_config_idx, indented_syslog)
              new_content = '\n'.join(lines)
              
              # Write back
              with open(ossec_conf, 'w') as f:
                  f.write(new_content)
              
              # Basic validation - check for XML structure (Wazuh may have multiple root elements)
              # We'll validate by checking that we have matching tags
              opening_tags = content.count('<ossec_config>')
              closing_tags = content.count('</ossec_config>')
              new_opening = new_content.count('<ossec_config>')
              new_closing = new_content.count('</ossec_config>')
              
              if new_opening == new_closing and new_opening > 0:
                  print(f"✅ Successfully injected syslog remote configuration ({new_opening} ossec_config blocks)")
              else:
                  print(f"⚠️  Warning: ossec_config tag mismatch (opening: {new_opening}, closing: {new_closing})")
              
              # Verify the syslog block was added
              if '<connection>syslog</connection>' in new_content:
                  print("✅ Verified syslog remote configuration is present")
              else:
                  print("❌ ERROR: Syslog remote configuration not found after injection")
                  sys.exit(1)
              PYTHON_SCRIPT
              
              echo "=== Step 3: Copying UniFi decoders and rules ==="
              # Copy UniFi decoder file
              if [ -f "/tmp/unifi-config/unifi_decoders.xml" ]; then
                cp /tmp/unifi-config/unifi_decoders.xml /tmp/ossec-etc/decoders/custom/unifi_decoders.xml
                chmod 640 /tmp/ossec-etc/decoders/custom/unifi_decoders.xml
                chown root:wazuh /tmp/ossec-etc/decoders/custom/unifi_decoders.xml
                echo "✅ Copied unifi_decoders.xml"
              fi
              
              # Copy UniFi rules file
              if [ -f "/tmp/unifi-config/unifi_rules.xml" ]; then
                cp /tmp/unifi-config/unifi_rules.xml /tmp/ossec-etc/rules/custom/unifi_rules.xml
                chmod 640 /tmp/ossec-etc/rules/custom/unifi_rules.xml
                chown root:wazuh /tmp/ossec-etc/rules/custom/unifi_rules.xml
                echo "✅ Copied unifi_rules.xml"
              fi
              
              echo "=== Step 4: Enabling debug logging for remoted ==="
              # Enable debug logging to see if messages are received
              local_internal_options="/tmp/ossec-etc/local_internal_options.conf"
              if [ -f "$local_internal_options" ]; then
                # Add debug logging if not already present
                if ! grep -q "wazuh_remoted.debug=2" "$local_internal_options"; then
                  echo "" >> "$local_internal_options"
                  echo "# Debug logging for remoted (to see received syslog messages)" >> "$local_internal_options"
                  echo "wazuh_remoted.debug=2" >> "$local_internal_options"
                  echo "✅ Enabled debug logging for remoted"
                else
                  echo "⚠️  Debug logging already enabled"
                fi
              else
                echo "⚠️  local_internal_options.conf not found, creating it..."
                cat > "$local_internal_options" << 'EOF'
# local_internal_options.conf
# Debug logging for remoted (to see received syslog messages)
wazuh_remoted.debug=2
EOF
                chmod 640 "$local_internal_options"
                chown root:wazuh "$local_internal_options"
                echo "✅ Created local_internal_options.conf with debug logging"
              fi
              
              echo "=== Configuration complete! ==="
              echo "✅ Syslog remote configured"
              echo "✅ UniFi decoders and rules deployed"
              echo "✅ Debug logging enabled for remoted"
          volumeMounts:
            - name: syslog-config
              mountPath: /tmp/syslog-config
              readOnly: true
            - name: unifi-decoder-config
              mountPath: /tmp/unifi-config
              readOnly: true
            - name: ossec-etc
              mountPath: /tmp/ossec-etc
          securityContext:
            runAsUser: 0  # Root needed to write files and set ownership
      containers:
      - name: wazuh-server
        image: wazuh/wazuh-manager:4.14.1
        resources:
          limits:
            cpu: 2000m
            memory: 4Gi
          requests:
            cpu: 1000m
            memory: 2Gi
        ports:
          - containerPort: 1514
            name: agent-tcp
            protocol: TCP
          - containerPort: 1515
            name: agent-udp
            protocol: UDP
          - containerPort: 514
            name: syslog-udp
            protocol: UDP
          - containerPort: 55000
            name: api
            protocol: TCP
        volumeMounts:
          - name: logs
            mountPath: /var/ossec/logs
          - name: ossec-etc
            mountPath: /var/ossec/etc
          - name: filebeat-config
            mountPath: /etc/filebeat/filebeat.yml
            subPath: filebeat.yml
            readOnly: true
          - name: indexer-certs
            mountPath: /etc/filebeat/certs/root-ca.pem
            subPath: root-ca.pem
            readOnly: true
  volumeClaimTemplates:
  - metadata:
      name: logs
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: truenas-nfs
      resources:
        requests:
          storage: 10Gi
